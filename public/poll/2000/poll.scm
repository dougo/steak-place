;; some poll-processing stuff.  Lots of adhockery and spaghetti code.

(load "/usr/share/slib/sort.scm")

(define *year* "2000")

(define <entry> (make-record-type 'entry '(voter records text)))
(define entry->voter (record-accessor <entry> 'voter))
(define entry->records (record-accessor <entry> 'records))
(define entry->text (record-accessor <entry> 'text))

(define <voter> (make-record-type 'voter '(number lastname fullname address)))
(define voter->number (record-accessor <voter> 'number))
(define voter->lastname (record-accessor <voter> 'lastname))
(define voter->fullname (record-accessor <voter> 'fullname))
(define voter->address (record-accessor <voter> 'address))

(define (display-string-list l)
  (for-each (lambda (line) (display line) (newline)) l)
  (values))

(define *entries* '())
(define *keys* '())
(define *canonical* '())
(define *votes* '())

(define (go) (process-files "mbox" "table" "canon"))

(define (process-files raw keys canon)
  (read-entries raw)
  (read-record-table keys)
  (read-canonical-table canon)
  (make-vote-table *entries*)
  (display (length *entries*))
  (display " entries, ")
  (display (length *votes*))
  (display " votes.")
  (newline)
  (write-by-votes *votes*)
  (write-by-artist *votes*)
  (write-voters *entries*)
  (values))

(define (read-entries raw)
  (let ((port (open-input-file raw)))
    (set! *entries*
	  (sort-by-voter
	   (let loop ((i 0))
	     (let ((entry (read-entry i port)))
	       (if entry
		   (cons entry (loop (+ i 1)))
		   '())))))))

(define (compare-records r1 r2)
  (string-ci<? (key r1) (key r2)))

(define (read-record-table name)
  (set! *keys* (read-line-pairs name)))

(define (read-canonical-table name)
  (set! *canonical* (read-line-pairs name)))

(define (read-line-pairs name)
  (let ((port (open-input-file name)))
    (let loop ()
      (let ((line (read-line port)))
	(if (string? line)
	    (cons (cons line (read-line port)) (loop))
	    '())))))

(define (key record)
  (let ((p (assoc record *keys*)))
    (if p (cdr p) (guess-record-key record))))

(define (read-entry i port)
  (let ((who (read-header port)))
    (if who
	(call-with-values
	 (lambda () (read-body port))
	 (lambda (records text)
	   ((record-constructor <entry>) (make-voter i who) records text)))
	#f)))

(define read-header #f)
(define read-body #f)
(let ((first-line #f))
  (set! read-header
    (lambda (port)
      (let loop ((from #f))
	(if first-line
	    (let ((line first-line))
	      (set! first-line #f)
	      (loop from))
	    (let ((line (read-line port)))
	      (if (and (string? line) (> (string-length line) 0))
		  (cond ((and (> (string-length line) 6)
			      (string=? (substring line 0 6) "From: "))
			 (loop (substring line 6 (string-length line))))
			(else (loop from)))
		  from))))))
  (set! read-body
	(lambda (port)
	  (let loop ((records '()) (text '()))
	    (let ((line (read-line port)))
	      (if (string? line)
		  (if (and (> (string-length line) 4)
			   (string=? "From " (substring line 0 5)))
		      (begin
			(set! first-line line)
			(values (reverse records) (reverse text)))
		      (if (and (> (string-length line) 0)
			       (char=? #\$ (string-ref line 0)))
			  (let ((line2 (substring line 1 (string-length line))))
			    (loop (cons line2 records) (cons line text)))
			  (loop records (cons line text))))
		  (values (reverse records) (reverse text))))))))

(define (mappend f l) (apply append (map f l)))

(define (list-records entries)
  (mappend entry->records entries))

(define (guess-record-key record)
  (list->string
   (reverse
    (let loop ((chars (string->list record)) (key '()))
      (if (null? chars)
	  key
	  (let ((char (car chars)))
	    (cond ((char-whitespace? char)
		   (cond ((null? key)
			  (loop (cdr chars) key))
			 ((string-ci=? (list->string (reverse key)) "the")
			  (loop (cdr chars) '()))
			 (else key)))
		  ((char-alphabetic? char)
		   (loop (cdr chars) (cons char key)))
		  (else (loop (cdr chars) key)))))))))

(define (make-vote-table entries)
  (set! *votes* (sort-by-votes (coalesce (make-key-voters-pairs entries)))))

(define (make-key-voters-pairs entries)
  (sort (mappend
	 (lambda (entry)
	   (let ((voter (entry->voter entry)))
	     (map (lambda (record) (cons (key record) (list (cons voter record))))
		  (entry->records entry))))
	 entries)
	(lambda (p1 p2) (string-ci<? (car p1) (car p2)))))

(define (coalesce key-voters-pairs)
  (let loop ((pairs key-voters-pairs) (table '()) (last-key ""))
    (if (null? pairs)
	(reverse table)
	(let* ((key-voters-pair (car pairs))
	       (key (car key-voters-pair))
	       (voters (cdr key-voters-pair))
	       (voter-record-pair (car voters)))
	  (if (string-ci=? key last-key)
	      (let* ((last-key-voters-pair (car table))
		     (last-voters (cdr last-key-voters-pair)))
		(loop (cdr pairs)
		      (cons (cons last-key (cons voter-record-pair last-voters))
			    (cdr table))
		      last-key))
	      (loop (cdr pairs) (cons key-voters-pair table) key))))))

(define (sort-by-votes votes)
  (sort votes (lambda (v1 v2)
		(let ((l1 (length (cdr v1)))
		      (l2 (length (cdr v2))))
		  (or (> l1 l2)
		      (and (not (< l1 l2))
			   (string-ci<? (car v1) (car v2))))))))

(define (display-votes votes)
  (for-each (lambda (key.voters)
	      (let ((key (car key.voters))
		    (voters (cdr key.voters)))
		(display (length voters))
		(display " ") (display (canonical-record-name key voters))
		(newline)
		(for-each
		 (lambda (voter.record)
		   (let ((voter (car voter.record))
			 (record (cdr voter.record)))
		     (display " ")
		     (display (voter->fullname voter))
		     (newline)))
		 voters)))
	    votes))

(define (write-by-votes votes)
  (with-output-to-file "byvotes.html"
    (lambda ()
      (display "<html><head><title>Chugchanga-L Poll ")
      (display *year*)
      (display " - By Votes</title></head>")
      (newline)
      (display "<body><hr><h1><a href=\"voters.html\">Chugchanga-L Members</a>' Favorite Records of ")
      (display *year*)
      (display "</h1>")
      (newline)
      (display "<table><tr><th><font size=-3>no. of votes</font></th><th>Record</th><th>Voters</th></tr>")
      (newline)
      (for-each 
       (lambda (record-votes)
	 (let ((key (car record-votes))
	       (voters (cdr record-votes)))
	   (display "<tr><td>")
	   (display (length voters))
	   (display "</td><td><a href=\"byartist.html#")
	   (display (make-anchor key))
	   (display "\">")
	   (display (htmlize-record-name (canonical-record-name key voters)))
	   (display "</a></td>")
	   (newline)
	   (display "<td><font size=-3>")
	   (write-record-voters 
	    (sort voters (lambda (v1 v2) (compare-voters (car v1) (car v2)))))
	   (newline)))
       votes)
      (display "</table></body></html>")
      (newline))))

(define (write-by-artist votes)
  (with-output-to-file "byartist.html"
    (lambda ()
      (display "<html><head><title>Chugchanga-L Poll ")
      (display *year*)
      (display " - By Artist</title></head>")
      (newline)
      (display "<body><hr><h1><a href=\"voters.html\">Chugchanga-L Members</a>' Favorite Records of ")
      (display *year*)
      (display "</h1>")
      (newline)
      (display "<table><tr><th><font size=-3>no. of votes</font></th><th>Record</th><th>Voters</th></tr>")
      (newline)
      (for-each
       (lambda (record-votes)
	 (let ((key (car record-votes))
	       (voters (cdr record-votes)))
	   (display "<tr><td>")
	   (display (length voters))
	   (display "</td><td><a name=\"")
	   (display (make-anchor key))
	   (display "\">")
	   (display (htmlize-record-name (canonical-record-name key voters)))
	   (display "</a></td>")
	   (newline)
	   (display "<td><font size=-3>")
	   (write-record-voters 
	    (sort voters (lambda (v1 v2) (compare-voters (car v1) (car v2)))))
	   (newline)))
       (sort votes (lambda (v1 v2) (string-ci<? (car v1) (car v2)))))
      (display "</table></body></html>")
      (newline))))

(define (write-record-voters voters)
  (if (null? voters)
      (display "</font></td></tr>")
      (let ((voter (caar voters)))
	(display "<a href=\"")
	(display (voter->number voter))
	(display ".html\">")
	(display (voter->fullname voter))
	(display "</a>")
	(unless (null? (cdr voters)) (display ", "))
	(write-record-voters (cdr voters)))))

(define (canonical-record-name key votes)
  (let ((p (assoc-ci key *canonical*)))
    (if p (cdr p)
	(canonicalize-record-name (cdr (car votes))))))

(define (assoc-ci key alist)
  (cond ((null? alist) #f)
	((string-ci=? key (caar alist)) (car alist))
	(else (assoc-ci key (cdr alist)))))

(define (canonicalize-record-name name)
  (list->string
   (let loop ((l (skip-whitespace (string->list name))) (p '()))
     (cond ((char-numeric? (car l))
	    (loop (cdr l) (cons (car l) p)))
	   ((or (char=? (car l) #\.)
		(char=? (car l) #\)))
	    (skip-whitespace (cdr l)))
	   (else (append (reverse p) l))))))

(define (skip-whitespace chars)
  (cond ((null? chars) '())
	((or (char-whitespace? (car chars))
	     (char=? (car chars) #\*))
	 (skip-whitespace (cdr chars)))
	(else chars)))

(define (make-safe-for-html s)
  (list->string
   (let loop ((l (string->list s)))
     (if (null? l) l
	 (case (car l)
	   ((#\<) (append (string->list "&lt;") (loop (cdr l))))
	   ((#\>) (append (string->list "&gt;") (loop (cdr l))))
	   ((#\&) (append (string->list "&amp;") (loop (cdr l))))
	   (else (cons (car l) (loop (cdr l)))))))))

(define (make-voter i voter)
  (let ((name (voter-name voter)))
    ((record-constructor <voter>)
     i (car name) (name->string name) (voter-address voter))))

;returns list of words in name, last name first.
(define (voter-name voter)
  (let loop ((words (string->words voter)) (name '()))
    (if (null? words) name
	(let* ((word (car words))
	       (letter (string-ref word 0)))
	  (if (char=? letter #\<)
	      (loop (cdr words) name)
	      (begin (string-set! word 0 (char-upcase letter))
		     (loop (cdr words) (cons word name))))))))

(define (name->string name)
  (if (null? name)
      ""
      (begin (string-append (name->string (cdr name))
			    (if (null? (cdr name))
				""
				" ")
			    (car name)))))

(define (voter-address voter)
  (let loop ((words (string->words voter)))
    (if (null? words)
	#f
	(let* ((word (car words))
	       (letter (string-ref word 0)))
	  (if (char=? letter #\<)
	      (substring word 1 (- (string-length word) 1))
	      (loop (cdr words)))))))

(define (string->words s)
  (map list->string
       (map reverse
	    (let loop ((l (string->list s)) (words '()))
	      (cond ((null? l) (reverse words))
		    ((char-whitespace? (car l))
		      (loop (cdr l) (if (or (null? words) (null? (car words)))
					words
					(cons '() words))))
		    ((char=? (car l) #\")
		     (loop (cdr l) words))
		    (else
		      (loop (cdr l) (if (null? words)
					(list (list (car l)))
					(cons (cons (car l) (car words))
					      (cdr words))))))))))

(define (sort-by-voter entries)
  (sort entries (lambda (e1 e2)
		  (compare-voters (entry->voter e1) (entry->voter e2)))))

(define (compare-voters v1 v2)
  (string-ci<? (voter->lastname v1) (voter->lastname v2)))

(define (display-voters entries)
  (if (null? entries)
      (display "")
      (let* ((entry (car entries))
	     (voter (entry->voter entry))
	     (name (voter->fullname voter))
	     (addr (voter->address voter)))
	(display name)
	(display " ")
	(display addr)
	(newline)
	(display-voters (cdr entries)))))

(define (write-voters entries)
  (with-output-to-file "voters.html"
    (lambda ()
      (display "<html><head><title>Chugchanga-L Poll ")
      (display *year*)
      (display " - Voters</title></head>")
      (newline)
      (display "<body><hr><h1>Chugchanga-L Members Who Voted in the ")
      (display *year*)
      (display " Poll</h1>")
      (newline)
      (let loop ((entries entries) (prev #f))
	(if (null? entries)
	    (display "")
	    (let* ((entry (car entries))
		   (voter (entry->voter entry))
		   (addr (voter->address voter)))
	      (write-entry entry prev (cdr entries))
	      (display "<a href=\"")
	      (display (voter->number voter))
	      (display ".html\">")
	      (display (voter->fullname voter))
	      (display "</a><br>")
	      (newline)
	      (loop (cdr entries) entry))))
      (display "</body></html>")
      (newline))))

(define (write-entry entry prev next)
  (let* ((voter (entry->voter entry))
	 (name (voter->fullname voter))
	 (number (voter->number voter)))
    (with-output-to-file (string-append (number->string number) ".html")
      (lambda ()
	(display "<html><head><title>Chugchanga-L Poll ")
	(display *year*)
	(display " - ")
	(display name)
	(display "</title></head>")
	(newline)
	(display "<body>")
	(display-nav prev next)
	(display "<hr><h1>")
	(display name)
	(display "'s Chugchanga-L Poll ")
	(display *year*)
	(display " Entry</h1>")
	(newline)
	(newline)
	(let loop ((lines (entry->text entry)))
	  (if (null? lines) (newline)
	      (let* ((line (car lines))
		     (l (string-length line))
		     (c (if (> l 0) (string-ref line 0) #\ )))
		(unless (char=? c #\#)
			(case c
			  ((#\$)
			   (let ((record (substring line 1 l)))
			     (display "<a href=\"byartist.html#")
			     (display (make-anchor (key record)))
			     (display "\">")
			     (display (htmlize-record-name record))
			     (display "</a>")))
			  ((#\%)
			   (display (htmlize-record-name (substring line 1 l))))
			  (else
			   (display (make-safe-for-html line))))
			(display "<br>")
			(newline))
		(loop (cdr lines)))))
	(display "<hr>")
	(display-nav prev next)
	(display "</body></html>")
	(newline)))))

(define (display-nav prev next)
  (if prev
      (begin (display "<a href=\"")
	     (display (number->string (voter->number (entry->voter prev))))
	     (display ".html\">")
	     (display "prev")
	     (display "</a>"))
      (display "prev"))
  (display " | <a href=\"voters.html\">list</a> | ")
  (if (null? next)
      (display "next")
      (begin (display "<a href=\"")
	     (display (number->string (voter->number (entry->voter (car next)))))
	     (display ".html\">")
	     (display "next")
	     (display "</a>")))
  (display "<br>")
  (newline))

(define (make-anchor key)
  (let ((s2 (string-copy key)))
    (let loop ((i (- (string-length s2) 1)))
      (cond ((< i 0) s2)
	    ((char-whitespace? (string-ref s2 i))
	     (string-set! s2 i #\_)
	     (loop (- i 1)))
	    ((char-upper-case? (string-ref s2 i))
	     (string-set! s2 i (char-downcase (string-ref s2 i)))
	     (loop (- i 1)))
	    (else
	     (loop (- i 1)))))))

(define (htmlize-record-name name)
  (let* ((name (make-safe-for-html name))
	 (l (string-length name)))
    (let loop ((i 0) (j #f))
      (cond ((= i l) name)
	    ((char=? (string-ref name i) #\_)
	     (if j (string-append "<strong>" (substring name 0 j)
				  "</strong><cite>"
				  (substring name (+ j 1) i) "</cite>"
				  (substring name (+ i 1) l))
		 (loop (+ i 1) i)))
	    (else (loop (+ i 1) j))))))
