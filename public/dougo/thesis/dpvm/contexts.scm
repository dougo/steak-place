;	$Id: contexts.scm,v 1.4 2000/03/07 17:44:32 gregs Exp $	
;; 
;; CONTEXTS

(define-record-type context (format-args up-context/f) ())

(define (push-ctxt ctxt . args)
  (context-maker args ctxt))

(define (dump-context ctxt)
  (format #t "~%")
  (let loop ((ctxt ctxt) (i 0))
    (format #t "----------------------------------------~%")
    (format #t "~a" (spaces i))
    (let* ((head (car (context-format-args ctxt)))
	   (format-string
	    (if (symbol? head)
		(cond ((assoc head context-alist) => cdr)
		      (else (error "dump-context ~a" ctxt)))
		head)))
      (apply format (cons #t (cons format-string (cdr (context-format-args ctxt))))))
    (format #t "~%")
    (if (context-up-context/f ctxt)
	(loop (context-up-context/f ctxt) (+ i 3))
	(format #t "~%-----~%"))))

(define context-alist
  (list 
   (cons 'run-exps1 "run-exps, running pred ~a on values ~a.  Original exps: ~a")
   (cons 'run-exps2 "Running exp ~a in exps ~a" )
   (cons 'call-exp1 "calling ~a on ~a")
   (cons 'call-exp2 "call, getting arg values, exp: ~a")
   (cons 'call-exp3 "call, getting fun-value, exp: ~a")
   (cons 'callable1 "primop call, pred ~a, callable: ~a, lst/v: ~a")
   (cons 'callable2 "running closure body, callable: ~a, lst/v: ~a")
   (cons 'callable3 "callable, running primop ~a on values ~a")
   (cons 'unchecked1 "callable unchecked, callable = ~a, vals = ~a")
   (cons 'unchecked2 "running closure body unchecked, callable: ~a, vals: ~a")
   (cons 'unchecked3 "run-callable-unchecked -- not a callable: ~a")
   (cons 'cond-exp-else "run-cond-exp, running else exp in ~a")
   (cons 'cond-exp2 "run-cond-exp, running non-else then exp ~a")
   (cons 'cond-exp3 "run-cond-exp, running test exp ~a")
   (cons 'and-exp1 "and-exp, doing exp ~a of exps ~a")
   (cons 'or-exp1 "or-exp, doing exp ~a of exps ~a")
   (cons 'fun-exp1 "fun-exp, running pred ~a on closure ~a")
   (cons 'fun-exp2 "fun-exp, running fun-pred exp, exp: ~a")
   (cons 'recfun-exp1 "recfun-exp, running pred ~a on closure ~a")
   (cons 'recfun-exp2 "recfun-exp, getting closure for exp: ~a")
   (cons 'seq-exp1 "non-last exp in seq-exp, this exp: ~a, whole exp: ~a")
   (cons 'seq-exp2 "last exp in seq-exp, this exp: ~a, whole exp: ~a")
   (cons 'let-exp1 "let-exp, running body, exp: ~a, lst/v: ~a")
   (cons 'let-exp2 "let-exp, getting values, exp: ~a")
   (cons 'let-exp3 "let-exp, getting predicate, exp: ~a")
   (cons 'let*-exp1 "let*-exp, running val exp: ~a")
   (cons 'let*-exp2 "let*-exp, running body; exp = ~a")
   (cons 'let*-exp3 "let*-exp, running pred on values ~a")
   (cons 'let*-exp4 "let*-exp, evaling pred exp in ~a")
   (cons 'var-exp1 "Var exp, looking up var, exp: ~a")
   (cons 'lit-exp1 "Literal, converting to value, exp: ~a")
   (cons 'lit2val1 "Running pred ~a on string literal ~a")
   (cons 'lit2val2 "Running pred ~a on integer literal ~a")
   (cons 'and-pred1 "running non-last pred ~a in and-pred")
   (cons 'and-pred2 "running last pred ~a in and-pred")
   (cons 'or-pred1 "running non-last pred ~a in or-pred")
   (cons 'or-pred2 "running last pred ~a in or-pred")
   (cons 'not-pred1 "running not pred ~a on value ~a")
   (cons 'not-pred2 "running not pred ~a")
   (cons 'list-pred1 "running pred ~a in list-pred")
   (cons 'elt-pred1 "running elt-pred ~a on cell value ~a")
   (cons 'elt-pred2 "running elt-pred ~a on list-elt ~a")
   (cons 'val-pred1 "Running callable for pred ~a on value ~a")
   (cons 'lookup-var1 "Lookup-var, running pred ~a on value ~a")
   (cons 'set-cell1 "primop set-cell!, cell ~a, pred ~a, newval ~a")
   (cons 'check-pred1 "primop check-pred, running pred ~a on val ~a")
   (cons 'in-scope1 "primop in-scope?, var-sym = ~a")
   (cons 'deref-var1 "primop deref-var, var-sym = ~a")
   (cons 'bind-in-scope1 "primop bind-in-scope, running pred ~a on val ~a")
   (cons 'apply1 "primop apply of ~a to ~a")
   (cons 'apply2 "checking args pred ~a in primop apply of ~a to ~a")
   (cons 'curry1 "running curried fun ~a on curried values ~a, more args: ~a")
   (cons 'rcurry1 "running rcurryied fun ~a, rcurried args: ~a, first args: ~a")
   (cons 'compose1 "running 2nd composed fun ~a on value ~a.  orig arg vals = ~a")
   (cons 'compose2 "running 1st composed fun ~a on values ~a")
   (cons 'tcompose1 "running 2nd tcomposed fun ~a on value ~a.  orig arg vals = ~a")
   (cons 'tcompose2 "running 1st tcomposed fun ~a on values ~a")
   (cons 'map1 "primop map, running fun ~a on list element ~a")
   (cons 'every-pred?1 "primop every-pred?, running pred ~a on list element ~a")
   (cons 'every?1 "primop every?, running fun ~a on values ~a")
   (cons 'any-pred?1 "primop any-pred?, running pred ~a on list element ~a")
   (cons 'any?1 "primop any?, running fun ~a on values ~a")
   ))

;; eof