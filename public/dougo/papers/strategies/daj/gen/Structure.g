// This file was generated by DAJ from Structure.cd.

header {
import edu.neu.ccs.demeter.*;
}

class StructureParser extends Parser;
options {
  defaultErrorHandler=false;
}

{
  static char unescapifyChar(String s) {
    char c = s.charAt(0);
    if (c == '\\') {
      switch (s.charAt(1)) {
      case 'n': c = '\n'; break;
      case 't': c = '\t'; break;
      case 'b': c = '\b'; break;
      case 'r': c = '\r'; break;
      case 'f': c = '\f'; break;
      case '\\': c = '\\'; break;
      case '\'': c = '\''; break;
      case '\"': c = '\"'; break;
      default:
       c = (char) Integer.parseInt(s.substring(1, s.length()), 8);
       break;
      }
    }
    return c;
  }
  static String unescapify(String s) {
    char str[] = new char[s.length()];
    int i = 0, o = 0;
    while (i < s.length()) {
      char c = s.charAt(i++);
      if (c == '\\') {
       int j = i + 1;
       while (j < s.length() &&
              Character.digit(s.charAt(j), 8) != -1) {
         j++;
       }
       c = unescapifyChar(s.substring(i-1, j));
       i = j;
      }
      str[o++] = c;
    }
    return String.valueOf(str, 0, o);
  }
}

parseA returns [A it]
  {
    it = new A();
    B the_b = null;
    C the_c = null;
    D the_d = null;
  }
  :
  "a"
  the_b=parseB
    { it.b = the_b; }
  the_c=parseC
    { it.c = the_c; }
  the_d=parseD
    { it.d = the_d; }
  commonY[it]
  ;

parseB returns [B it]
  {
    it = new B();
    Z the_z = null;
  }
  :
  "b"
  the_z=parseZ
    { it.z = the_z; }
  commonY[it]
  ;

parseD returns [D it]
  {
    it = new D();
    Y the_y = null;
  }
  :
  "d"
  the_y=parseY
    { it.y = the_y; }
  commonZ[it]
  ;

parseC returns [C it]
  {
    it = new C();
    E the_e = null;
  }
  :
  the_e=parseE
    { it.e = the_e; }
  ;

parseY returns [Y it]
  : it=parseA
  | it=parseB
  ;
commonY[Y it]
  {
  }
  :
  ;

parseZ returns [Z it]
  : it=parseD
  | it=parseE
  ;
commonZ[Z it]
  {
  }
  :
  ;

parseE returns [E it]
  {
    it = new E();
  }
  :
  "e"
  commonZ[it]
  ;

parseboolean returns [boolean it]
  : "true" { it = true; }
  | "false" { it = false; }
  ;
parsechar returns [char it]
  : t:CHAR_LITERAL
  { String s = t.getText();
    it = unescapifyChar(s.substring(1, s.length()-1)); }
  ;
parsebyte returns [byte it]
  { int i; }
  : i=parseint
  { it = (byte) i; }
  ;
parseshort returns [short it]
  { int i; }
  : i=parseint
  { it = (short) i; }
  ;
parseint returns [int it]
  : t:NUM_INT
  { it = Integer.parseInt(t.getText()); }
  ;
parselong returns [long it]
  : t:NUM_LONG
  { String s = t.getText();
    it = Long.parseLong(s.substring(0,s.length()-1)); }
  ;
parsefloat returns [float it]
  : t:NUM_FLOAT
  { String s = t.getText();
    it = Float.parseFloat(s.substring(0,s.length()-1)); }
  ;
parsedouble returns [double it]
  : t:NUM_DOUBLE
  { String s = t.getText();
    if (s.endsWith("D") || s.endsWith("d"))
      it = Double.parseDouble(s.substring(0,s.length()-1));
    else
      it = Double.parseDouble(s); }
  ;
parseBoolean returns [Boolean it]
  : "true" { it = Boolean.TRUE; }
  | "false" { it = Boolean.FALSE; }
  ;
parseCharacter returns [Character it]
  { char c; }
  : c=parsechar
  { it = new Character(c); }
  ;
parseByte returns [Byte it]
  { byte b; }
  : b=parsebyte
  { it = new Byte(b); }
  ;
parseInteger returns [Integer it]
  { int i; }
  : i=parseint
  { it = new Integer(i); }
  ;
parseLong returns [Long it]
  { long l; }
  : l=parselong
  { it = new Long(l); }
  ;
parseFloat returns [Float it]
  { float f; }
  : f=parsefloat
  { it = new Float(f); }
  ;
parseDouble returns [Double it]
  { double d; }
  : d=parsedouble
  { it = new Double(d); }
  ;
parseNumber returns [Number it]
  : it=parseInteger
  | it=parseLong
  | it=parseFloat
  | it=parseDouble
  ;
parseString returns [String it]
  : t:STRING_LITERAL
  { String s = t.getText();
    it = unescapify(s.substring(1, s.length()-1)); }
  ;
parseIdent returns [Ident it]
  : t:IDENT
  { it = new Ident(t.getText()); }
  ;

class StructureLexer extends Lexer;

options {
  testLiterals=false;
  k=2;
  charVocabulary='\u0003'..'\uFFFF';
  codeGenBitsetTestThreshold=20;
  defaultErrorHandler=false;
}

tokens { DOT; }

IDENT options { testLiterals=true; }:
  ('a'..'z'|'A'..'Z'|'_'|'$') ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'$')*
  ;

// Mostly copied from JavaLexer in antlr/examples/java/java/java.g:

// Whitespace -- ignored
WS	:	(	' '
		|	'\t'
		|	'\f'
			// handle newlines
		|	(	options {generateAmbigWarnings=false;}
			:	"\r\n"	// Evil DOS
			|	'\r'		// Macintosh
			|	'\n'		// Unix (the right way)
			)
			{ newline(); }
		)+
		{ _ttype = Token.SKIP; }
	;

// Single-line comments
SL_COMMENT
	:	"//"
		(~('\n'|'\r'))* ('\n'|'\r'('\n')?)
		{$setType(Token.SKIP); newline();}
	;

// multiple-line comments
ML_COMMENT
	:	"/*"
		(	/*	'\r' '\n' can be matched in one alternative or by matching
				'\r' in one iteration and '\n' in another.	I am trying to
				handle any flavor of newline that comes in, but the language
				that allows both "\r\n" and "\r" and "\n" to all be valid
				newline is ambiguous.	Consequently, the resulting grammar
				must be ambiguous.	I'm shutting this warning off.
			 */
			options {
				generateAmbigWarnings=false;
			}
		:
			{ LA(2)!='/' }? '*'
		|	'\r' '\n'		{newline();}
		|	'\r'			{newline();}
		|	'\n'			{newline();}
		|	~('*'|'\n'|'\r')
		)*
		"*/"
		{$setType(Token.SKIP);}
	;


// character literals
CHAR_LITERAL
	:	'\'' ( ESC | ~'\'' ) '\''
	;

// string literals
STRING_LITERAL
	:	'"' (ESC|~('"'|'\\'))* '"'
	;


// escape sequence -- note that this is protected; it can only be called
//	 from another lexer rule -- it will not ever directly return a token to
//	 the parser
// There are various ambiguities hushed in this rule.	The optional
// '0'...'9' digit matches should be matched here rather than letting
// them go back to STRING_LITERAL to be matched.	ANTLR does the
// right thing by matching immediately; hence, it's ok to shut off
// the FOLLOW ambig warnings.
protected
ESC
	:	'\\'
		(	'n'
		|	'r'
		|	't'
		|	'b'
		|	'f'
		|	'"'
		|	'\''
		|	'\\'
		|	('u')+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
		|	'0'..'3'
			(
				options {
					warnWhenFollowAmbig = false;
				}
			:	'0'..'7'
				(
					options {
						warnWhenFollowAmbig = false;
					}
				:	'0'..'7'
				)?
			)?
		|	'4'..'7'
			(
				options {
					warnWhenFollowAmbig = false;
				}
			:	'0'..'7'
			)?
		)
	;


// hexadecimal digit (again, note it's protected!)
protected
HEX_DIGIT
	:	('0'..'9'|'A'..'F'|'a'..'f')
	;


// a dummy rule to force vocabulary to be all characters (except special
//	 ones that ANTLR uses internally (0 to 2)
protected
VOCAB
	:	'\3'..'\377'
	;


// a numeric literal
NUM_INT
	{boolean isDecimal=false; Token t=null;}
		:	 '.' {_ttype = DOT;}
						(	('0'..'9')+ (EXPONENT)? (f1:FLOAT_SUFFIX {t=f1;})?
								{
				if (t != null && t.getText().toUpperCase().indexOf('F')>=0) {
									_ttype = NUM_FLOAT;
				}
				else {
									_ttype = NUM_DOUBLE; // assume double
				}
				}
						)?

	|	(	'0' {isDecimal = true;} // special case for just '0'
			(	('x'|'X')
				(											// hex
					// the 'e'|'E' and float suffix stuff look
					// like hex digits, hence the (...)+ doesn't
					// know when to stop: ambig.	ANTLR resolves
					// it correctly by matching immediately.	It
					// is therefor ok to hush warning.
					options {
						warnWhenFollowAmbig=false;
					}
				:	HEX_DIGIT
				)+
			|	('0'..'7')+									// octal
			)?
		|	('1'..'9') ('0'..'9')*	{isDecimal=true;}		// non-zero decimal
		)
		(	('l'|'L') { _ttype = NUM_LONG; }

		// only check to see if it's a float if looks like decimal so far
		|	{isDecimal}?
						(	 '.' ('0'..'9')* (EXPONENT)? (f2:FLOAT_SUFFIX {t=f2;})?
						|	 EXPONENT (f3:FLOAT_SUFFIX {t=f3;})?
						|	 f4:FLOAT_SUFFIX {t=f4;}
						)
						{
			if (t != null && t.getText().toUpperCase() .indexOf('F') >= 0) {
								_ttype = NUM_FLOAT;
			}
						else {
							 _ttype = NUM_DOUBLE; // assume double
			}
			}
				)?
	;


// a couple protected methods to assist in matching floating point numbers
protected
EXPONENT
	:	('e'|'E') ('+'|'-')? ('0'..'9')+
	;


protected
FLOAT_SUFFIX
	:	'f'|'F'|'d'|'D'
	;


