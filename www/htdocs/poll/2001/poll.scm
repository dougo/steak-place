;; some poll-processing stuff.  Lots of adhockery and spaghetti code.

;(load "/usr/share/slib/sort.scm")
(require (lib "list.ss"))
(define sort mergesort)

(define *year* "2001")

(define-struct entry (voter records top-record text))

(define-struct voter (number lastname fullname address))

(define (display-string-list l)
  (for-each (lambda (line) (display line) (newline)) l)
  (void))

(define *entries* '())
(define *keys* '())
(define *canonical* '())
(define *names* '())
(define *votes* '())

(define (go) (process-files "mbox" "table" "canon" "names"))

(define (process-files raw keys canon names)
  (read-entries raw)
  (read-record-table keys)
  (read-canonical-table canon)
  (read-names-table names)
  (make-vote-table *entries*)
  (display (length *entries*))
  (display " entries, ")
  (display (length *votes*))
  (display " votes.")
  (newline)
  (write-by-votes *votes*)
  (write-by-artist *votes*)
  (write-voters *entries*)
  (void))

(define (read-entries raw)
  (let ((port (open-input-file raw)))
    (set! *entries*
	  (sort-by-voter
	   (let loop ((i 0))
	     (let ((entry (read-entry i port)))
	       (if entry
		   (cons entry (loop (+ i 1)))
		   '())))))))

(define (read-record-table name)
  (set! *keys* (read-line-pairs name)))

(define (read-canonical-table name)
  (set! *canonical* (read-line-pairs name)))

(define (read-line-pairs name)
  (let ((port (open-input-file name)))
    (let loop ()
      (let ((line (read-line port)))
	(if (string? line)
	    (cons (cons line (read-line port)) (loop))
	    '())))))

(define (read-names-table name)
  (set! *names*
	(let ((port (open-input-file name)))
	  (let loop ()
	    (let ((line (read-line port)))
	      (if (string? line)
		  (cons (normalize line) (loop))
		  '()))))))

(define (normalize string)
  (let loop ((chars (string->list string)) (words '()) (word '()))
    (if (null? chars)
	(if (null? word)
	    words
	    (cons (list->string (reverse word)) words))
	(let ((char (char-downcase (car chars))))
	  (if (or (char-alphabetic? char) (char-numeric? char))
	      (loop (cdr chars) words (cons char word))
	      (loop (cdr chars)
		    (if (null? word)
			words
			(cons (list->string (reverse word)) words))
		    '()))))))

(define (key record)
  (let ((p (assoc record *keys*)))
    (if p (cdr p) (guess-record-key record))))

(define (read-entry i port)
  (let ((who (read-header port)))
    (if who
	(let-values (((records top-record text) (read-body port)))
	  (make-entry (header->voter i who) records top-record text))
	#f)))

(define read-header #f)
(define read-body #f)
(let ((first-line #f))
  (set! read-header
    (lambda (port)
      (let loop ((from #f))
	(if first-line
	    (let ((line first-line))
	      (set! first-line #f)
	      (loop from))
	    (let ((line (read-line port)))
	      (if (and (string? line) (> (string-length line) 0))
		  (cond ((and (> (string-length line) 6)
			      (string=? (substring line 0 6) "From: "))
			 (loop (substring line 6 (string-length line))))
			(else (loop from)))
		  from))))))
  (set! read-body
	(lambda (port)
	  (let loop ((records '()) (top-record #f) (text '()))
	    (let ((line (read-line port)))
	      (if (string? line)
		  (if (and (> (string-length line) 4)
			   (string=? "From " (substring line 0 5)))
		      (begin
			(set! first-line line)
			(values (reverse records) top-record (reverse text)))
		      (if (and (> (string-length line) 0)
			       (or (char=? #\$ (string-ref line 0))
				   (char=? #\% (string-ref line 0))))
			  (let ((line2 (substring line 1 (string-length line))))
			    (loop (cons line2 records)
				  (if (char=? #\% (string-ref line 0))
				      line2
				      top-record)
				  (cons line text)))
			  (loop records top-record (cons line text))))
		  (values (reverse records) top-record (reverse text))))))))

(define (mappend f l) (apply append (map f l)))

(define (list-records entries)
  (mappend entry-records entries))

(define (guess-record-key record)
  (define (return key word)
    (let loop ((words (reverse (cons (list->string (reverse word)) key))))
      (if (null? words)
	  ""
	  (let ((rest (loop (cdr words))))
	    (if (zero? (string-length rest))
		(car words)
		(string-append (car words) "-" rest)))))
;    (apply string-append (reverse (cons (list->string (reverse word)) key)))
    )
  (let loop ((chars (string->list record)) (key '()) (word '()))
    (if (null? chars)
	(return key word)
	(let ((char (car chars)))
	  (cond ((and (char-numeric? char) (null? key))
		 (loop (cdr chars) key word))
		((or (char-alphabetic? char) (char-numeric? char))
		 (loop (cdr chars) key (cons (char-downcase char) word)))
		((and (or (char=? char #\() (char=? char #\[))
		      (not (null? key)))
		 (return key word))
		(else
		 (let ((word (list->string (reverse word))))
		   (cond ((or (zero? (string-length word))
			      (string=? word "the")
			      (string=? word "and")
			      (and (not (null? key))
				   (or (string=? word (car key))
				       (and (string=? word "artists")
					    (string=? (car key) "a")))))
			  (loop (cdr chars) key '()))
			 ((string=? word "various")
			  (loop (cdr chars) (cons "a" (cons "v" key)) '()))
			 (else
			  (let ((key (cons word key)))
			    (if (member key *names*)
				(loop (cdr chars)
				      (append (cdr key) (list (car key)))
				      '())
				(loop (cdr chars) key '()))))))))))))

(define (make-vote-table entries)
  (set! *votes* (sort-by-votes (coalesce (make-key-voters-pairs entries))))
  (set! *keys* (mappend (lambda (key-voters-pair)
			  (let ((key (car key-voters-pair))
				(voters (cdr key-voters-pair)))
			    (map (lambda (voter-record-list)
				   (cons (cadr voter-record-list) key))
				 voters)))
			*votes*)))

(define (make-key-voters-pairs entries)
  (sort (mappend
	 (lambda (entry)
	   (let ((voter (entry-voter entry))
		 (top-record (entry-top-record entry)))
	     (map (lambda (record)
		    (list (key record)
			  (list voter record (eq? record top-record))))
		  (entry-records entry))))
	 entries)
	(lambda (p1 p2) (string-ci<? (car p1) (car p2)))))

(define (coalesce key-voters-pairs)
  (let loop ((pairs key-voters-pairs) (table '()) (last-key "no-last-key"))
    (if (null? pairs)
	(reverse table)
	(let* ((key-voters-pair (car pairs))
	       (key (car key-voters-pair))
	       (voters (cdr key-voters-pair))
	       (voter-record-pair (car voters))
	       (prefix-len (min (string-length key) (string-length last-key)))
	       (key-prefix (substring key 0 prefix-len))
	       (last-key-prefix (substring last-key 0 prefix-len)))
	  (if (and (> prefix-len 2) (string=? key-prefix last-key-prefix))
	      (let* ((last-key-voters-pair (car table))
		     (last-voters (cdr last-key-voters-pair)))
		(loop (cdr pairs)
		      (cons (cons key-prefix
				  (cons voter-record-pair last-voters))
			    (cdr table))
		      key-prefix))
	      (loop (cdr pairs) (cons key-voters-pair table) key))))))

(define (sort-by-votes votes)
  (sort votes (lambda (v1 v2)
		(let ((l1 (length (cdr v1)))
		      (l2 (length (cdr v2))))
		  (or (> l1 l2)
		      (and (= l1 l2)
			   (let ((t1 (length (filter caddr (cdr v1))))
				 (t2 (length (filter caddr (cdr v2)))))
			   (or (> t1 t2)
			       (and (= t1 t2)
				    (string-ci<? (car v1) (car v2)))))))))))

(define (display-votes votes)
  (for-each (lambda (key.voters)
	      (let ((key (car key.voters))
		    (voters (cdr key.voters)))
		(display (length voters))
		(display " ") (display (canonical-record-name key voters))
		(newline)
		(for-each
		 (lambda (voter.record)
		   (let ((voter (car voter.record))
			 (record (cdr voter.record)))
		     (display " ")
		     (display (voter-fullname voter))
		     (newline)))
		 voters)))
	    votes))

(define (write-by-votes votes)
  (with-output-to-file "byvotes.html"
    (lambda ()
      (display "<html><head><title>Chugchanga-L Poll ")
      (display *year*)
      (display " - By Votes</title></head>")
      (newline)
      (display "<body><hr><h1><a href=\"voters.html\">Chugchanga-L Members</a>' Favorite Records of ")
      (display *year*)
      (display "</h1>")
      (newline)
      (display "<table><tr><th>Rank</th><th>no. of votes</th><th>Record</th><th>Voters</th></tr>")
      (newline)
      (let loop ((index 1) (rank 1) (votes votes)
		 (last-num-votes -1) (last-num-top-votes -1))
	(unless (null? votes)
	  (let* ((key (caar votes))
		 (voters (cdar votes))
		 (num-votes (length voters))
		 (num-top-votes (length (filter caddr voters))))
	    (unless (and (= num-votes last-num-votes)
			 (= num-top-votes last-num-top-votes))
	      (set! rank index))
	    (display "<tr><td>")
	    (display rank)
	    (display ".")
	    (display "</td><td>")
	    (display num-votes)
	    (when (positive? num-top-votes)
	      (display " (") (display num-top-votes) (display ")"))
	    (display "</td><td><a href=\"byartist.html#")
	    (display (make-anchor key))
	    (display "\">")
	    (display (htmlize (canonical-record-name key voters)))
	    (display "</a></td>")
	    (newline)
	    (display "<td><font size=-3>")
	    (write-record-voters 
	     (sort voters (lambda (v1 v2) (compare-voters (car v1) (car v2)))))
	    (newline)
	    (loop (+ index 1) rank (cdr votes) num-votes num-top-votes))))
      (display "</table></body></html>")
      (newline))
    'replace))

(define (write-by-artist votes)
  (with-output-to-file "byartist.html"
    (lambda ()
      (display "<html><head><title>Chugchanga-L Poll ")
      (display *year*)
      (display " - By Artist</title></head>")
      (newline)
      (display "<body><hr><h1><a href=\"voters.html\">Chugchanga-L Members</a>' Favorite Records of ")
      (display *year*)
      (display "</h1>")
      (newline)
      (display "<table><tr><th><font size=-3>no. of votes</font></th><th>Record</th><th>Voters</th></tr>")
      (newline)
      (for-each
       (lambda (record-votes)
	 (let ((key (car record-votes))
	       (voters (cdr record-votes)))
	   (display "<tr><td>")
	   (display (length voters))
	   (display "</td><td><a name=\"")
	   (display (make-anchor key))
	   (display "\">")
	   (display (htmlize (canonical-record-name key voters)))
	   (display "</a></td>")
	   (newline)
	   (display "<td><font size=-3>")
	   (write-record-voters 
	    (sort voters (lambda (v1 v2) (compare-voters (car v1) (car v2)))))
	   (newline)))
       (sort votes (lambda (v1 v2) (string<? (car v1) (car v2)))))
      (display "</table></body></html>")
      (newline))
    'replace))

(define (write-record-voters voters)
  (if (null? voters)
      (display "</font></td></tr>")
      (let ((voter (caar voters))
	    (top-record? (caddar voters)))
	(display "<a href=\"")
	(display (voter-number voter))
	(display ".html\">")
	(when top-record? (display "<b>"))
	(display (voter-fullname voter))
	(when top-record? (display "</b>"))
	(display "</a>")
	(unless (null? (cdr voters)) (display ", "))
	(write-record-voters (cdr voters)))))

(define (canonical-record-name key votes)
  (let ((p (assoc-ci key *canonical*)))
    (if p (cdr p)
	(let ((record-names (map cadr votes)))
	  (canonicalize-record-name (largest record-names string-length))))))

(define (largest list size)
  (let ((first (car list)))
    (if (null? (cdr list))
	first
	(let ((second-largest (largest (cdr list) size)))
	  (if (> (size second-largest) (size first))
	      second-largest
	      first)))))

(define (assoc-ci key alist)
  (cond ((null? alist) #f)
	((string-ci=? key (caar alist)) (car alist))
	(else (assoc-ci key (cdr alist)))))

(define (canonicalize-record-name name)
  (list->string
   (let loop ((l (skip-whitespace (string->list name))) (p '()))
     (cond ((null? l)
	    '())
	   ((char-numeric? (car l))
	    (loop (cdr l) (cons (car l) p)))
	   ((or (char=? (car l) #\.)
		(char=? (car l) #\))
		(char=? (car l) #\tab))
	    (skip-whitespace (cdr l)))
	   (else (append (reverse p) l))))))

(define (skip-whitespace chars)
  (cond ((null? chars) '())
	((or (char-whitespace? (car chars))
	     (char=? (car chars) #\*))
	 (skip-whitespace (cdr chars)))
	(else chars)))

(define (make-safe-for-html s)
  (list->string
   (let loop ((l (string->list s)))
     (if (null? l) l
	 (case (car l)
	   ((#\<) (append (string->list "&lt;") (loop (cdr l))))
	   ((#\>) (append (string->list "&gt;") (loop (cdr l))))
	   ((#\&) (append (string->list "&amp;") (loop (cdr l))))
	   (else (cons (car l) (loop (cdr l)))))))))

(define (header->voter i header)
  (let ((name (header->voter-name header)))
    (make-voter
     i (car name) (name->string name) (header->voter-address header))))

;returns list of words in name, last name first.
(define (header->voter-name header)
  (let loop ((words (string->words header)) (name '()))
    (if (null? words) name
	(let* ((word (car words))
	       (first-letter (string-ref word 0))
	       (len (string-length word))
	       (last-letter (string-ref word (- len 1))))
	  (if (char=? first-letter #\<)
	      (loop (cdr words) name)
	      (begin (string-set! word 0 (char-upcase first-letter))
		     (if (char=? last-letter #\,)
			 (loop (append (cdr words)
				       (list (substring word 0 (- len 1))))
			       name)
			 (loop (cdr words) (cons word name)))))))))

(define (name->string name)
  (if (null? name)
      ""
      (begin (string-append (name->string (cdr name))
			    (if (null? (cdr name))
				""
				" ")
			    (car name)))))

(define (header->voter-address header)
  (let loop ((words (string->words header)))
    (if (null? words)
	#f
	(let* ((word (car words))
	       (letter (string-ref word 0)))
	  (if (char=? letter #\<)
	      (substring word 1 (- (string-length word) 1))
	      (loop (cdr words)))))))

(define (string->words s)
  (map list->string
       (map reverse
	    (let loop ((l (string->list s)) (words '()))
	      (cond ((null? l) (reverse words))
		    ((char-whitespace? (car l))
		      (loop (cdr l) (if (or (null? words) (null? (car words)))
					words
					(cons '() words))))
		    ((char=? (car l) #\")
		     (loop (cdr l) words))
		    (else
		      (loop (cdr l) (if (null? words)
					(list (list (car l)))
					(cons (cons (car l) (car words))
					      (cdr words))))))))))

(define (sort-by-voter entries)
  (sort entries (lambda (e1 e2)
		  (compare-voters (entry-voter e1) (entry-voter e2)))))

(define (compare-voters v1 v2)
  (string-ci<? (voter-lastname v1) (voter-lastname v2)))

(define (display-voters entries)
  (if (null? entries)
      (display "")
      (let* ((entry (car entries))
	     (voter (entry-voter entry))
	     (name (voter-fullname voter))
	     (addr (voter-address voter)))
	(display name)
	(display " ")
	(display addr)
	(newline)
	(display-voters (cdr entries)))))

(define (write-voters entries)
  (with-output-to-file "voters.html"
    (lambda ()
      (display "<html><head><title>Chugchanga-L Poll ")
      (display *year*)
      (display " - Voters</title></head>")
      (newline)
      (display "<body><hr><h1>Chugchanga-L Members Who Voted in the ")
      (display *year*)
      (display " Poll</h1>")
      (newline)
      (let loop ((entries entries) (prev #f))
	(if (null? entries)
	    (display "")
	    (let* ((entry (car entries))
		   (voter (entry-voter entry))
		   (addr (voter-address voter)))
	      (write-entry entry prev (cdr entries))
	      (display "<a href=\"")
	      (display (voter-number voter))
	      (display ".html\">")
	      (display (voter-fullname voter))
	      (display "</a><br>")
	      (newline)
	      (loop (cdr entries) entry))))
      (display "</body></html>")
      (newline))
    'replace))

(define (write-entry entry prev next)
  (let* ((voter (entry-voter entry))
	 (name (voter-fullname voter))
	 (number (voter-number voter)))
    (with-output-to-file (string-append (number->string number) ".html")
      (lambda ()
	(display "<html><head><title>Chugchanga-L Poll ")
	(display *year*)
	(display " - ")
	(display name)
	(display "</title></head>")
	(newline)
	(display "<body>")
	(display-nav prev next)
	(display "<hr><h1>")
	(display name)
	(display "'s Chugchanga-L Poll ")
	(display *year*)
	(display " Entry</h1>")
	(newline)
	(newline)
	(let loop ((lines (entry-text entry)))
	  (if (null? lines) (newline)
	      (let* ((line (car lines))
		     (l (string-length line))
		     (c (if (> l 0) (string-ref line 0) #\ )))
		(unless (char=? c #\#)
			(case c
			  ((#\$ #\%)
			   (let ((record (substring line 1 l)))
			     (display "<a href=\"byartist.html#")
			     (display (make-anchor (key record)))
			     (display "\">")
			     (display (htmlize record))
			     (display "</a>")))
			  (else
			   (display (htmlize line))))
			(display "<br>")
			(newline))
		(loop (cdr lines)))))
	(display "<hr>")
	(display-nav prev next)
	(display "</body></html>")
	(newline))
      'replace)))

(define (display-nav prev next)
  (if prev
      (begin (display "<a href=\"")
	     (display (number->string (voter-number (entry-voter prev))))
	     (display ".html\">")
	     (display "prev")
	     (display "</a>"))
      (display "prev"))
  (display " | <a href=\"voters.html\">list</a> | ")
  (if (null? next)
      (display "next")
      (begin (display "<a href=\"")
	     (display (number->string (voter-number (entry-voter (car next)))))
	     (display ".html\">")
	     (display "next")
	     (display "</a>")))
  (display "<br>")
  (newline))

(define (make-anchor key)
  (let ((s2 (string-copy key)))
    (let loop ((i (- (string-length s2) 1)))
      (cond ((< i 0) s2)
	    ((char-whitespace? (string-ref s2 i))
	     (string-set! s2 i #\_)
	     (loop (- i 1)))
	    ((char-upper-case? (string-ref s2 i))
	     (string-set! s2 i (char-downcase (string-ref s2 i)))
	     (loop (- i 1)))
	    (else
	     (loop (- i 1)))))))

(define (htmlize text)
  (add-tags (make-safe-for-html text)))

(define (add-tags text)
  (let loop ((text text) (l (string-length text))
	     (i 0) (j #f))
      (cond ((= i l) text)
	    ((char=? (string-ref text i) #\_)
	     (if j (loop (string-append
			  (substring text 0 j)
			  "<cite>" (substring text (+ j 1) i) "</cite>"
			  (substring text (+ i 1) l))
			 (+ l 11)
			 (+ i 1)
			 #f)
		 (loop text l (+ i 1) i)))
	    ((and (> l (+ i 7))
		  (string=? (substring text i (+ i 7)) "http://"))
	     (let loop2 ((j (+ i 7)))
	       (if (or (= j l)
		       (let ((char (string-ref text j)))
			 (or (char-whitespace? char)
			     (char=? char #\>)
			     (char=? char #\))
			     (and (> l (+ j 3))
				  (string=? (substring text j (+ j 4))
					    "&gt;")))))
		   (let ((url (substring text i j)))
		     (loop (string-append
			    (substring text 0 i)
			    "<a href=\"" url "\">" url "</a>"
			    (substring text j l))
			   (+ l 15 (- j i))
			   (+ j 15)
			   #f))
		   (loop2 (+ j 1)))))		     
	    (else (loop text l (+ i 1) j)))))

